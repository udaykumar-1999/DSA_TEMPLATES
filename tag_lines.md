ğŸ§  CORE LEETCODE TAG LINES (BY PATTERN)
ğŸ” Frequency / Counting / HashMap

â€œFrequency problems should be order-agnostic.â€

â€œCounts matter, positions donâ€™t.â€

â€œDuplicates cascade â€” fix globally, not locally.â€

â€œIf uniqueness is required, track whatâ€™s already used.â€

â€œReduce counts, not characters.â€

â€œWhen conflicts repeat, use a while, not an if.â€

ğŸ‘‰ Triggers:

Anagrams

Unique frequencies

Top-K frequent

Character replacement

ğŸ§® Sorting / Greedy

â€œSort to simplify decisions, not to solve the problem.â€

â€œGreedy works when every local choice is safe globally.â€

â€œAlways take the smallest loss / earliest finish / largest gain.â€

â€œIf sorting feels forced, thereâ€™s probably a set or heap.â€

â€œSorting reveals structure; logic enforces correctness.â€

ğŸ‘‰ Triggers:

Intervals

Scheduling

Minimizing deletions

Greedy proofs

ğŸªŸ Sliding Window / Two Pointers

â€œWindow grows until it breaks, then shrink.â€

â€œMove one pointer at a time â€” never rewind.â€

â€œValid window â†’ expand; invalid window â†’ contract.â€

â€œEach index is visited at most twice.â€

â€œIf brute force checks subarrays, sliding window fits.â€

ğŸ‘‰ Triggers:

Longest/shortest substring

At most K

Subarrays

Continuous ranges

ğŸ§  Set / Uniqueness

â€œSeen before? A set belongs here.â€

â€œMembership check beats scanning.â€

â€œIf order doesnâ€™t matter, use a set.â€

â€œUniqueness is a state, not a position.â€

â€œIf youâ€™re asking â€˜have I seen thisâ€™, reach for a set.â€

ğŸ‘‰ Triggers:

Distinct elements

Cycles

Repeated states

ğŸŒ³ Stack / Monotonic Stack

â€œIf you look backward, a stack is waiting.â€

â€œNext greater/smaller â†’ monotonic stack.â€

â€œStack keeps unresolved elements.â€

â€œPush when growing, pop when violated.â€

â€œEach element is pushed and popped once.â€

ğŸ‘‰ Triggers:

Histogram

Next greater element

Valid parentheses

Span problems

ğŸ§© Dynamic Programming (DP)

â€œBrute force with memory.â€

â€œDefine state before code.â€

â€œIf choices overlap, DP exists.â€

â€œTop-down thinks, bottom-up executes.â€

â€œState = what you need to know to decide.â€

ğŸ‘‰ Triggers:

Fibonacci-like

Subsequence

Partitioning

Min/max cost paths

ğŸŒŠ BFS / DFS / Graphs

â€œTraversal order matters only for shortest paths.â€

â€œVisited set prevents infinite loops.â€

â€œBFS = minimum steps.â€

â€œDFS = explore completely.â€

â€œGraph problems hide inside grids.â€

ğŸ‘‰ Triggers:

Islands

Shortest path

Dependency resolution

ğŸ§ª Binary Search

â€œSearch space, not the array.â€

â€œIf answer is monotonic, binary search applies.â€

â€œMid is a question, not an index.â€

â€œLeft = possible, right = impossible (or vice versa).â€

â€œBinary search reduces decisions, not data.â€

ğŸ‘‰ Triggers:

Minimum/maximum feasible value

Rotated arrays

Optimization problems

â›“ Linked List

â€œTwo pointers meet when thereâ€™s a cycle.â€

â€œDummy node simplifies edge cases.â€

â€œReverse means rewire, not recreate.â€

â€œThink in references, not values.â€

ğŸ‘‰ Triggers:

Reversal

Cycle detection

Merging lists

ğŸ§  GENERAL INTERVIEW MINDSET TAGS (VERY IMPORTANT)

â€œFirst make it correct, then make it fast.â€

â€œIf logic feels brittle, youâ€™re missing an invariant.â€

â€œLocal checks fail when constraints are global.â€

â€œIf code is long, idea isnâ€™t clear yet.â€

â€œEdge cases define correctness.â€

â€œWhile loops fix what if statements canâ€™t.â€

ğŸ† TOP 5 TAGS YOU SHOULD AUTO-RECALL (Memorize These)

â€œDuplicates cascade â€” fix globally, not locally.â€

â€œSearch space, not the array.â€

â€œWindow grows until it breaks.â€

â€œEach element is processed at most twice.â€

â€œIf uniqueness matters, order usually doesnâ€™t.â€
